-- ENUMs
do $$ begin
  create type challenge_visibility as enum ('public','private');
exception when duplicate_object then null; end $$;
do $$ begin
  create type member_role as enum ('owner','member');
exception when duplicate_object then null; end $$;
do $$ begin
  create type member_status as enum ('joined','left','banned');
exception when duplicate_object then null; end $$;

-- Tables
create table if not exists public.challenges (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  category text,
  visibility challenge_visibility not null default 'public',
  duration_days int not null default 7,
  cover_emoji text,
  invite_code text,
  owner_user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now()
);

create table if not exists public.challenge_members (
  challenge_id uuid not null references public.challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role member_role not null default 'member',
  status member_status not null default 'joined',
  joined_at timestamptz not null default now(),
  primary key (challenge_id, user_id)
);

create table if not exists public.challenge_messages (
  id bigint generated by default as identity primary key,
  challenge_id uuid not null references public.challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  content text not null,
  created_at timestamptz not null default now()
);

-- RLS
alter table public.challenges enable row level security;
alter table public.challenge_members enable row level security;
alter table public.challenge_messages enable row level security;

create policy read_public_challenges
on public.challenges for select to authenticated
using (
  visibility = 'public'
  or owner_user_id = auth.uid()
  or exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenges.id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
);

create policy create_challenges
on public.challenges for insert to authenticated
with check ( owner_user_id = auth.uid() );

create policy owner_update_challenges
on public.challenges for update to authenticated
using ( owner_user_id = auth.uid() );

create policy owner_delete_challenges
on public.challenges for delete to authenticated
using ( owner_user_id = auth.uid() );

create policy read_members
on public.challenge_members for select to authenticated
using (
  exists (
    select 1 from public.challenges c
    where c.id = challenge_members.challenge_id and (
      c.visibility = 'public'
      or c.owner_user_id = auth.uid()
      or exists (
        select 1 from public.challenge_members m2
        where m2.challenge_id = c.id
          and m2.user_id = auth.uid()
          and m2.status = 'joined'
      )
    )
  )
);

create policy join_public_or_owner_adds_private
on public.challenge_members for insert to authenticated
with check (
  (
    exists (select 1 from public.challenges c
            where c.id = challenge_members.challenge_id
              and c.visibility = 'public')
    and user_id = auth.uid()
  )
  or exists (select 1 from public.challenges c2
             where c2.id = challenge_members.challenge_id
               and c2.owner_user_id = auth.uid())
);

create policy member_updates_self
on public.challenge_members for update to authenticated
using ( user_id = auth.uid() );

create policy read_challenge_messages
on public.challenge_messages for select to authenticated
using (
  exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenge_messages.challenge_id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
  or exists (
    select 1 from public.challenges c
    where c.id = challenge_messages.challenge_id
      and c.owner_user_id = auth.uid()
  )
);

create policy post_challenge_messages
on public.challenge_messages for insert to authenticated
with check (
  exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenge_messages.challenge_id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
  or exists (
    select 1 from public.challenges c
    where c.id = challenge_messages.challenge_id
      and c.owner_user_id = auth.uid()
  )
);

-- View for counts
create or replace view public.challenges_with_counts as
select
  c.*,
  (select count(*)::int
   from public.challenge_members m
   where m.challenge_id = c.id and m.status = 'joined') as participants
from public.challenges c;

-- RPC: get user id by email (for owner invites)
create or replace function public.get_user_id_by_email(p_email text)
returns uuid
language sql
security definer
set search_path = public, auth
as $$
  select id from auth.users where email = p_email limit 1;
$$;
grant execute on function public.get_user_id_by_email(text) to authenticated;