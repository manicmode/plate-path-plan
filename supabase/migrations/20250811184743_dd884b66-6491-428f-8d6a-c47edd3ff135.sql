begin;

-- 1) ENUMs (idempotent)
do $$ begin
  create type challenge_visibility as enum ('public','private');
exception when duplicate_object then null; end $$;

do $$ begin
  create type member_role as enum ('owner','member');
exception when duplicate_object then null; end $$;

do $$ begin
  create type member_status as enum ('joined','left','banned');
exception when duplicate_object then null; end $$;

-- 2) Core tables (idempotent create)
create table if not exists public.challenges (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  category text,
  visibility challenge_visibility not null default 'public',
  duration_days int not null default 7,
  cover_emoji text,
  invite_code text,
  owner_user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now()
);

create table if not exists public.challenge_members (
  challenge_id uuid not null references public.challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role member_role not null default 'member',
  status member_status not null default 'joined',
  joined_at timestamptz not null default now(),
  primary key (challenge_id, user_id)
);

-- 3) challenge_messages: create if missing, otherwise migrate type safely
-- Create table if it doesn't exist (with correct types)
do $$
begin
  if not exists (
    select 1 from information_schema.tables
    where table_schema='public' and table_name='challenge_messages'
  ) then
    create table public.challenge_messages (
      id bigint generated by default as identity primary key,
      challenge_id uuid not null references public.challenges(id) on delete cascade,
      user_id uuid not null references auth.users(id) on delete cascade,
      content text not null,
      created_at timestamptz not null default now()
    );
  end if;
end
$$;

-- If the table exists but challenge_id is text, convert it to uuid without data loss
do $$
declare
  coltype text;
  bad_rows int;
begin
  select data_type into coltype
  from information_schema.columns
  where table_schema='public' and table_name='challenge_messages' and column_name='challenge_id';

  if coltype = 'text' then
    -- Add tmp column
    alter table public.challenge_messages add column if not exists challenge_id_tmp uuid;

    -- Try direct cast for rows that already look like uuids
    update public.challenge_messages cm
    set challenge_id_tmp = case
      when cm.challenge_id ~ '^[0-9a-fA-F-]{36}$' then cm.challenge_id::uuid
      else null
    end
    where challenge_id_tmp is null;

    -- Attempt join-based mapping if previous schema stored challenge id as text of c.id::text
    update public.challenge_messages cm
    set challenge_id_tmp = c.id
    from public.challenges c
    where cm.challenge_id_tmp is null
      and cm.challenge_id = c.id::text;

    -- Validate: all rows must now have tmp
    select count(*) into bad_rows
    from public.challenge_messages
    where challenge_id_tmp is null;

    if bad_rows > 0 then
      raise exception 'Migration aborted: % challenge_messages rows cannot be mapped to a UUID. Example rows: %',
        bad_rows,
        (select json_agg(t) from (
          select id, challenge_id from public.challenge_messages
          where challenge_id_tmp is null
          limit 5
        ) t);
    end if;

    -- Drop existing FK if any (defensively)
    do $f$
    declare
      con record;
    begin
      for con in
        select conname
        from pg_constraint
        where conrelid = 'public.challenge_messages'::regclass
          and contype = 'f'
      loop
        execute format('alter table public.challenge_messages drop constraint %I', con.conname);
      end loop;
    end
    $f$;

    -- Replace column
    alter table public.challenge_messages drop column challenge_id;
    alter table public.challenge_messages rename column challenge_id_tmp to challenge_id;

    -- Re-add FK + not null
    alter table public.challenge_messages
      alter column challenge_id set not null,
      add constraint challenge_messages_challenge_id_fkey
        foreign key (challenge_id) references public.challenges(id) on delete cascade;

  end if;
end
$$;

-- Ensure user_id FK exists (defensive)
do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conrelid = 'public.challenge_messages'::regclass
      and conname = 'challenge_messages_user_id_fkey'
  ) then
    alter table public.challenge_messages
      add constraint challenge_messages_user_id_fkey
      foreign key (user_id) references auth.users(id) on delete cascade;
  end if;
end
$$;

-- 4) RLS & policies (drop-if-exists, then create)
alter table public.challenges enable row level security;
alter table public.challenge_members enable row level security;
alter table public.challenge_messages enable row level security;

-- Drop old policies if present to avoid duplicate_object
do $$
begin
  perform 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='read_public_challenges';
  if found then execute 'drop policy read_public_challenges on public.challenges'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='create_challenges';
  if found then execute 'drop policy create_challenges on public.challenges'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='owner_update_challenges';
  if found then execute 'drop policy owner_update_challenges on public.challenges'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='owner_delete_challenges';
  if found then execute 'drop policy owner_delete_challenges on public.challenges'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenge_members' and policyname='read_members';
  if found then execute 'drop policy read_members on public.challenge_members'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenge_members' and policyname='join_public_or_owner_adds_private';
  if found then execute 'drop policy join_public_or_owner_adds_private on public.challenge_members'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenge_members' and policyname='member_updates_self';
  if found then execute 'drop policy member_updates_self on public.challenge_members'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenge_messages' and policyname='read_challenge_messages';
  if found then execute 'drop policy read_challenge_messages on public.challenge_messages'; end if;

  perform 1 from pg_policies where schemaname='public' and tablename='challenge_messages' and policyname='post_challenge_messages';
  if found then execute 'drop policy post_challenge_messages on public.challenge_messages'; end if;
end
$$;

create policy read_public_challenges
on public.challenges for select to authenticated
using (
  visibility = 'public'
  or owner_user_id = auth.uid()
  or exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenges.id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
);

create policy create_challenges
on public.challenges for insert to authenticated
with check ( owner_user_id = auth.uid() );

create policy owner_update_challenges
on public.challenges for update to authenticated
using ( owner_user_id = auth.uid() );

create policy owner_delete_challenges
on public.challenges for delete to authenticated
using ( owner_user_id = auth.uid() );

create policy read_members
on public.challenge_members for select to authenticated
using (
  exists (
    select 1 from public.challenges c
    where c.id = challenge_members.challenge_id and (
      c.visibility = 'public'
      or c.owner_user_id = auth.uid()
      or exists (
        select 1 from public.challenge_members m2
        where m2.challenge_id = c.id
          and m2.user_id = auth.uid()
          and m2.status = 'joined'
      )
    )
  )
);

create policy join_public_or_owner_adds_private
on public.challenge_members for insert to authenticated
with check (
  (
    exists (select 1 from public.challenges c
            where c.id = challenge_members.challenge_id
              and c.visibility = 'public')
    and user_id = auth.uid()
  )
  or exists (select 1 from public.challenges c2
             where c2.id = challenge_members.challenge_id
               and c2.owner_user_id = auth.uid())
);

create policy member_updates_self
on public.challenge_members for update to authenticated
using ( user_id = auth.uid() );

create policy read_challenge_messages
on public.challenge_messages for select to authenticated
using (
  exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenge_messages.challenge_id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
  or exists (
    select 1 from public.challenges c
    where c.id = challenge_messages.challenge_id
      and c.owner_user_id = auth.uid()
  )
);

create policy post_challenge_messages
on public.challenge_messages for insert to authenticated
with check (
  exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenge_messages.challenge_id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
  or exists (
    select 1 from public.challenges c
    where c.id = challenge_messages.challenge_id
      and c.owner_user_id = auth.uid()
  )
);

-- 5) View (idempotent replace)
create or replace view public.challenges_with_counts as
select
  c.*,
  (
    select count(*)::int
    from public.challenge_members m
    where m.challenge_id = c.id and m.status = 'joined'
  ) as participants
from public.challenges c;

-- RPC (idempotent replace)
create or replace function public.get_user_id_by_email(p_email text)
returns uuid
language sql
security definer
set search_path = public, auth
as $$
  select id from auth.users where email = p_email limit 1;
$$;

grant execute on function public.get_user_id_by_email(text) to authenticated;

commit;