begin;

-- 1) ENUMs
do $$ begin
  create type challenge_visibility as enum ('public','private');
exception when duplicate_object then null; end $$;

do $$ begin
  create type member_role as enum ('owner','member');
exception when duplicate_object then null; end $$;

do $$ begin
  create type member_status as enum ('joined','left','banned');
exception when duplicate_object then null; end $$;

-- 2) Core tables
create table if not exists public.challenges (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  category text,
  visibility challenge_visibility not null default 'public',
  duration_days int not null default 7,
  cover_emoji text,
  invite_code text,
  owner_user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now()
);

create table if not exists public.challenge_members (
  challenge_id uuid not null references public.challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role member_role not null default 'member',
  status member_status not null default 'joined',
  joined_at timestamptz not null default now(),
  primary key (challenge_id, user_id)
);

-- 3) challenge_messages: rebuild safely if empty+wrong type; else create if missing
do $$
declare
  exists_msgs boolean := false;
  coltype text := null;
  rowcount bigint := 0;
begin
  select exists(
    select 1 from information_schema.tables
    where table_schema='public' and table_name='challenge_messages'
  ) into exists_msgs;

  if exists_msgs then
    select data_type into coltype
    from information_schema.columns
    where table_schema='public' and table_name='challenge_messages' and column_name='challenge_id';

    execute 'select count(*) from public.challenge_messages' into rowcount;

    -- If wrong type AND no data, drop & recreate cleanly
    if coltype = 'text' and rowcount = 0 then
      drop table public.challenge_messages;
      create table public.challenge_messages (
        id bigint generated by default as identity primary key,
        challenge_id uuid not null references public.challenges(id) on delete cascade,
        user_id uuid not null references auth.users(id) on delete cascade,
        content text not null,
        created_at timestamptz not null default now()
      );
    end if;
  else
    -- Not exists: create with correct schema
    create table public.challenge_messages (
      id bigint generated by default as identity primary key,
      challenge_id uuid not null references public.challenges(id) on delete cascade,
      user_id uuid not null references auth.users(id) on delete cascade,
      content text not null,
      created_at timestamptz not null default now()
    );
  end if;
end
$$;

-- 4) RLS enable
alter table public.challenges enable row level security;
alter table public.challenge_members enable row level security;
alter table public.challenge_messages enable row level security;

-- 5) Drop any old policies to avoid duplicates
do $$
begin
  -- challenges
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='read_public_challenges') then
    drop policy read_public_challenges on public.challenges;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='create_challenges') then
    drop policy create_challenges on public.challenges;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='owner_update_challenges') then
    drop policy owner_update_challenges on public.challenges;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenges' and policyname='owner_delete_challenges') then
    drop policy owner_delete_challenges on public.challenges;
  end if;

  -- challenge_members
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenge_members' and policyname='read_members') then
    drop policy read_members on public.challenge_members;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenge_members' and policyname='join_public_or_owner_adds_private') then
    drop policy join_public_or_owner_adds_private on public.challenge_members;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenge_members' and policyname='member_updates_self') then
    drop policy member_updates_self on public.challenge_members;
  end if;

  -- challenge_messages
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenge_messages' and policyname='read_challenge_messages') then
    drop policy read_challenge_messages on public.challenge_messages;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='challenge_messages' and policyname='post_challenge_messages') then
    drop policy post_challenge_messages on public.challenge_messages;
  end if;
end
$$;

-- 6) Recreate standard policies

create policy read_public_challenges
on public.challenges for select to authenticated
using (
  visibility = 'public'
  or owner_user_id = auth.uid()
  or exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenges.id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
);

create policy create_challenges
on public.challenges for insert to authenticated
with check ( owner_user_id = auth.uid() );

create policy owner_update_challenges
on public.challenges for update to authenticated
using ( owner_user_id = auth.uid() );

create policy owner_delete_challenges
on public.challenges for delete to authenticated
using ( owner_user_id = auth.uid() );

create policy read_members
on public.challenge_members for select to authenticated
using (
  exists (
    select 1 from public.challenges c
    where c.id = challenge_members.challenge_id and (
      c.visibility = 'public'
      or c.owner_user_id = auth.uid()
      or exists (
        select 1 from public.challenge_members m2
        where m2.challenge_id = c.id
          and m2.user_id = auth.uid()
          and m2.status = 'joined'
      )
    )
  )
);

create policy join_public_or_owner_adds_private
on public.challenge_members for insert to authenticated
with check (
  (
    exists (select 1 from public.challenges c
            where c.id = challenge_members.challenge_id
              and c.visibility = 'public')
    and user_id = auth.uid()
  )
  or exists (select 1 from public.challenges c2
             where c2.id = challenge_members.challenge_id
               and c2.owner_user_id = auth.uid())
);

create policy member_updates_self
on public.challenge_members for update to authenticated
using ( user_id = auth.uid() );

create policy read_challenge_messages
on public.challenge_messages for select to authenticated
using (
  exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenge_messages.challenge_id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
  or exists (
    select 1 from public.challenges c
    where c.id = challenge_messages.challenge_id
      and c.owner_user_id = auth.uid()
  )
);

create policy post_challenge_messages
on public.challenge_messages for insert to authenticated
with check (
  exists (
    select 1 from public.challenge_members m
    where m.challenge_id = challenge_messages.challenge_id
      and m.user_id = auth.uid()
      and m.status = 'joined'
  )
  or exists (
    select 1 from public.challenges c
    where c.id = challenge_messages.challenge_id
      and c.owner_user_id = auth.uid()
  )
);

commit;